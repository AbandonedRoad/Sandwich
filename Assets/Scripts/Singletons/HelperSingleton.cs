//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.18444
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using Singleton;
using Assets.Scripts.Blocks;
using Assets.Scripts.Enums;
using Assets.Scripts.Debug;
using LevelCreation;
using Enums;
using Random = UnityEngine.Random;

namespace Singletons
{
	public class HelperSingleton
	{
		public string LastLoadedLevel {get; set;}

		private static HelperSingleton _instance;
		
		/// <summary>
		/// Gets instance
		/// </summary>
		public static HelperSingleton Instance
		{
			get
			{
				if (_instance == null) 
				{
					_instance = new HelperSingleton();
				}
				
				return _instance;
			}
		}

		/// <summary>
		/// Sets the cursor.
		/// </summary>
		/// <param name="newCursor">New cursor.</param>
		public GameObject GetTopMostGO(GameObject gameObject, bool getLastTagged)
		{
			if (gameObject == null)
			{
				return null;
			}

			GameObject intermediateResult = null;
			GameObject parent = gameObject;
			while (parent.transform.parent != null)
			{
				var newParent = parent.transform.parent.gameObject;

				if (getLastTagged && newParent.tag != "Untagged")
				{
					intermediateResult = newParent;
				}

				if (newParent.transform.position == Vector3.zero)
				{
					// This is only a container - we reached the end!
					return parent;
				}

				parent = newParent;
			}

			if (parent.tag == "Untagged" && getLastTagged)
			{
				// If we wanted to return the last tagged, return it.
				return intermediateResult != null 
					? intermediateResult
					: parent;
			}

			return parent;
		}
	
		/// <summary>
		/// Gets the GO which is the nearest to the player.
		/// </summary>
		/// <param name="">.</param>
		/// <param name="myPosition">My position.</param>
		public GameObject GetNearestGameObject(IEnumerable<GameObject> objects, Vector3 myPosition)
		{
			objects = objects.Distinct();
			Dictionary<GameObject, float> distanceToObject = new Dictionary<GameObject, float>();

			if (!objects.Any() || objects.All(ob => ob == null))
			{
				return null;
			}

			foreach (var go in objects)
			{
				distanceToObject.Add(go, (go.transform.position - myPosition).magnitude);
			}

			return distanceToObject.OrderBy(pair => pair.Value).First().Key;
		}

		/// <summary>
		/// Returns the center of the gameobject, using the collidor attached to the go. If no collidier is attached, transform.position is returned.
		/// </summary>
		/// <returns>The center of game object.</returns>
		/// <param name="gameObject">Game object.</param>
		public Vector3 GetCenterOfGameObject(GameObject gameObject)
		{
			var collidor = gameObject.GetComponent<Collider>();
			if (collidor != null)
			{
				return collidor.bounds.center;
			}

			return gameObject.transform.position;
		}

		/// <summary>
		/// Splits up.
		/// </summary>
		/// <returns>The up.</returns>
		/// <param name="splitUp">Split up.</param>
		public string SplitUp(string splitUp)
		{
			string output = String.Empty;
			foreach (char letter in splitUp)
			{
				if (Char.IsUpper(letter) && output.Length > 0)
					output += " " + letter;
				else
					output += letter;
			}

			return output;
		}

		/// <summary>
		/// Destroies the level.
		/// </summary>
		public void DestroyLevel()
		{
            PrefabSingleton.Instance.CeillingParent.transform.Cast<Transform>().ToList().ForEach(tr => GameObject.Destroy(tr.gameObject));
			PrefabSingleton.Instance.LevelParent.transform.Cast<Transform>().ToList().ForEach(tr => GameObject.Destroy(tr.gameObject));
			PrefabSingleton.Instance.LightsParent.transform.Cast<Transform>().ToList().ForEach(tr => GameObject.Destroy(tr.gameObject));
			PrefabSingleton.Instance.PickupParent.transform.Cast<Transform>().ToList().ForEach(tr => GameObject.Destroy(tr.gameObject));
			PrefabSingleton.Instance.StandBlockParent.transform.Cast<Transform>().ToList().ForEach(tr => GameObject.Destroy(tr.gameObject));
            PrefabSingleton.Instance.DebugParent.transform.Cast<Transform>().ToList().ForEach(tr => GameObject.Destroy(tr.gameObject));
			
			// Destroy all Hearts
			var hearts = GameObject.FindGameObjectsWithTag("Heart");
			foreach (var heart in hearts) 
			{
				GameObject.Destroy(heart);
			}

            CalculationSingleton.Instance.ActualCreationScope = new CreationScope();
		}

        /// <summary>
        /// Create an empty GO at a specific point with a given text.
        /// </summary>
        /// <param name="text"></param>
        /// <param name="rotation"></param>
        public void CreateDebugGOAtPosition(string text, Vector3 position)
        {
            GameObject empty = new GameObject();
            empty.transform.position = position;
            empty.transform.name = "DEBUG";
            empty.transform.parent = PrefabSingleton.Instance.DebugParent;

            var info = empty.AddComponent<DebugInfo>();
            info.DebugInfoValue = text;
        }

        /// <summary>
        /// Gets a Wall Descriptor
        /// </summary>
        /// <param name="block"></param>
        /// <param name="specificWall"></param>
        /// <returns></returns>
        public WallDescriptor GetWallDescription(GameObject block, int specificWall = 1)
        {
            if (block == null)
            {
                Debug.LogError("block was NULL - no Walldescriptor!");
                return null;
            }

            var wallDescriptors = block.GetComponentsInChildren<WallDescriptor>();
            return wallDescriptors.First(wd => wd.gameObject.name == String.Concat("Wall", specificWall.ToString()));
        }

        /// <summary>
        /// Gets a Wall Descriptor
        /// </summary>
        /// <param name="block"></param>
        /// <param name="specificWall"></param>
        /// <returns></returns>
        public IEnumerable<WallDescriptor> GetAllDoorWalls(GameObject block)
        {
            if (block == null)
            {
                Debug.LogError("block was NULL - no Walldescriptor!");
                return null;
            }

            var wallDescriptors = block.GetComponentsInChildren<WallDescriptor>();
            
            return wallDescriptors.Where(wd => wd.Descriptor == WallDescription.Door).ToList();
        }

        /// <summary>
        /// Gets a Wall Descriptor
        /// </summary>
        /// <param name="block"></param>
        /// <param name="specificWall"></param>
        /// <returns></returns>
        public IEnumerable<WallDescriptor> GetAllRealWalls(GameObject block)
        {
            if (block == null)
            {
                Debug.LogError("block was NULL - no Walldescriptor!");
                return null;
            }

            var wallDescriptors = block.GetComponentsInChildren<WallDescriptor>();
            return wallDescriptors.Where(wd => wd.Descriptor == WallDescription.Wall).ToList();
        }

        /// <summary>
        /// Returns the Opposite of the actual HorzDirection enum
        /// </summary>
        /// <param name="direction"></param>
        /// <returns></returns>
        public HorzDirection GetOpposite(HorzDirection direction)
        {
            if (direction == HorzDirection.Backwards)
            {
                return HorzDirection.Forward;
            }
            else if (direction == HorzDirection.Forward) 
            {
                return HorzDirection.Backwards;
            }
            else if (direction == HorzDirection.Left)
            {
                return HorzDirection.Right;
            }
            else
            {
                return HorzDirection.Left;
            }
        }

        /// <summary>
        /// Returns the Opposite of the actual HorzDirection enum
        /// </summary>
        /// <param name="direction"></param>
        /// <returns></returns>
        public VertDirection GetOpposite(VertDirection direction)
        {
            if (direction == VertDirection.Down)
            {
                return VertDirection.Up;
            }
            else
            {
                return VertDirection.Down;
            }
        }

        /// <summary>
        /// Gets the size.
        /// </summary>
        /// <returns>The size.</returns>
        /// <param name="objectToCheck">Object to check.</param>
        public Vector3 GetSize(GameObject objectToCheck)
        {
            if (objectToCheck == null)
            {
                Debug.LogError("Object to check is null!");
            }

            Renderer renderer = objectToCheck.tag == "RenderObject"
                ? objectToCheck.GetComponent<Renderer>()
                : objectToCheck.GetComponentsInChildren<Renderer>(true).ToList().FirstOrDefault(rend => rend.gameObject.tag == "RenderObject");
            if (renderer == null)
            {
                Debug.LogError("No RenderObject found for: " + objectToCheck.name);
            }

            return renderer != null
                ? renderer.bounds.size
                : Vector3.one;
        }
    }
}